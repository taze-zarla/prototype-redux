{"version":3,"sources":["commons/actions.ts","features/colors/SearchForm.tsx","app/rootReducer.ts","features/colors/colorsReducer.ts","api/client.ts","commons/shuffle.ts","app/sagas.ts","app/store.ts","features/colors/ColorsList.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["colorToggled","createAction","colorsRequested","colorsReceived","colorsRequestFailed","SearchForm","useState","keywords","setKeywords","dispatch","useDispatch","debouncedDispatch","useDebouncedCallback","aria-label","value","onChange","e","term","currentTarget","callback","colors","createReducer","status","error","builder","addCase","state","action","color","find","id","payload","selected","combineReducers","createRootReducer","injectedReducers","wrappedFetch","fetchRetry","fetch","ApiClient","controller","this","AbortController","abort","endpoint","a","requestOptions","body","customConfig","headers","config","method","signal","retryOn","JSON","stringify","response","console","log","ok","json","data","Error","statusText","Promise","reject","message","shuffle","items","i","length","j","Math","floor","random","temp","fetchColors","watchFetchColors","rootSaga","client","execute","shuffled","put","slice","cancelled","takeLatest","all","call","useTypedSelector","useSelector","ColorsList","colorsStatus","useEffect","renderedColors","map","className","style","width","height","userSelect","backgroundColor","hex","cursor","outline","onClick","name","display","flexWrap","App","exact","path","render","to","Boolean","window","location","hostname","match","store","initialState","reduxSagaMonitorOptions","sagaMiddleware","createSagaMiddleware","runSaga","run","middlewares","enhancers","createInjectorsEnhancer","configureStore","reducer","middleware","getDefaultMiddleware","preloadedState","devTools","process","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.e737e002.chunk.js","sourcesContent":["import { createAction } from '@reduxjs/toolkit'\r\nimport { Color } from '../features/colors/colorsReducer'\r\n\r\nexport type ActionType =\r\n  | 'COLOR_TOGGLED'\r\n  | 'COLORS_REQUESTED'\r\n  | 'COLORS_RECEIVED'\r\n  | 'COLORS_REQUEST_FAILED'\r\n\r\n/**\r\n * Colors actions [Synchronous-related]\r\n */\r\nexport const colorToggled = createAction<Color, ActionType>('COLOR_TOGGLED')\r\n\r\n/**\r\n * Colors actions [Asynchronous/Saga-related]\r\n */\r\nexport const colorsRequested = createAction<string, ActionType>('COLORS_REQUESTED')\r\nexport const colorsReceived = createAction<Color[], ActionType>('COLORS_RECEIVED')\r\nexport const colorsRequestFailed = createAction<string, ActionType>('COLORS_REQUEST_FAILED')","import React, { useState } from 'react'\r\nimport { useDispatch } from 'react-redux'\r\nimport { useDebouncedCallback } from 'use-debounce/lib'\r\nimport { colorsRequested } from '../../commons/actions'\r\n\r\nexport const SearchForm = () => {\r\n  const [keywords, setKeywords] = useState<string>('')\r\n\r\n  const dispatch = useDispatch()\r\n\r\n  const debouncedDispatch = useDebouncedCallback(dispatch, 500)\r\n\r\n  const onKeywordsChanged = (e: React.FormEvent<HTMLInputElement>) => {\r\n    const term = e.currentTarget.value\r\n    setKeywords(term)\r\n\r\n    if (term) {\r\n      debouncedDispatch.callback(colorsRequested(term))\r\n    }\r\n  }\r\n\r\n  return <div>\r\n    <div>============</div>\r\n    <div>Search Colors</div>\r\n    <input\r\n      aria-label=\"Enter search keywords\"\r\n      value={keywords}\r\n      onChange={onKeywordsChanged}\r\n    />\r\n  </div>\r\n}","import { combineReducers } from '@reduxjs/toolkit'\r\nimport { colorsReducer } from '../features/colors/colorsReducer'\r\n\r\nconst colors = { colors: colorsReducer }\r\n\r\nexport let rootReducer = combineReducers({\r\n  ...colors\r\n})\r\n\r\nexport default function createRootReducer(injectedReducers = {}) {\r\n  rootReducer = combineReducers({\r\n    ...colors,\r\n    ...injectedReducers\r\n  })\r\n\r\n  return rootReducer\r\n}\r\n\r\nexport type RootState = ReturnType<typeof rootReducer>","import { createReducer } from '@reduxjs/toolkit'\r\nimport {\r\n  colorsReceived,\r\n  colorsRequested,\r\n  colorsRequestFailed,\r\n  colorToggled,\r\n} from '../../commons/actions'\r\n\r\nexport interface Color {\r\n  id: string,\r\n  hex: string,\r\n  name: string,\r\n  selected: boolean,\r\n}\r\n\r\ninterface ColorsState {\r\n  colors: Color[]\r\n  status: 'idle' | 'requesting' | 'succeeded' | 'failed'\r\n  error: string | null\r\n}\r\n\r\nconst initialState: ColorsState = {\r\n  colors: [],\r\n  status: 'idle',\r\n  error: null\r\n}\r\n\r\nexport const colorsReducer = createReducer<ColorsState>(initialState, (builder) => {\r\n  builder.addCase(colorToggled, (state, action) => {\r\n    const color = state.colors.find(color => color.id === action.payload.id)\r\n\r\n    if (color) {\r\n      color.selected = !color.selected\r\n    }\r\n  })\r\n\r\n  builder.addCase(colorsRequested, (state) => {\r\n    state.status = 'requesting'\r\n  })\r\n\r\n  builder.addCase(colorsReceived, (state, action) => {\r\n    state.colors = action.payload\r\n    state.status = 'succeeded'\r\n  })\r\n\r\n  builder.addCase(colorsRequestFailed, (state, action) => {\r\n    state.error = action.payload\r\n    state.status = 'failed'\r\n  })\r\n})","// A tiny wrapper around fetch(), borrowed from\r\n// https://kentcdodds.com/blog/replace-axios-with-a-simple-custom-fetch-wrapper\r\nimport fetchRetry from 'fetch-retry'\r\n\r\nconst wrappedFetch = fetchRetry(fetch)\r\n\r\ntype RequestDelayFunction = ((\r\n  attempt: number,\r\n  error: Error | null,\r\n  response: Response | null\r\n) => number);\r\n\r\ntype RequestRetryOnFunction = ((\r\n  attempt: number,\r\n  error: Error | null,\r\n  response: Response | null\r\n) => boolean);\r\n\r\ninterface IRequestInitWithRetry extends RequestInit {\r\n  retries?: number;\r\n  retryDelay?: number | RequestDelayFunction;\r\n  retryOn?: number[] | RequestRetryOnFunction;\r\n}\r\n\r\ninterface ApiClientService {\r\n  abort(): void,\r\n  execute<T>(endpoint: string, requestOptions: RequestInit): Promise<T>\r\n}\r\n\r\n// TODO: add retry-ability\r\nexport class ApiClient implements ApiClientService {\r\n  controller: AbortController\r\n\r\n  constructor() {\r\n    this.controller = new AbortController()\r\n  }\r\n\r\n  abort() {\r\n    this.controller.abort()\r\n  }\r\n\r\n  async execute<T>(endpoint: string, requestOptions: IRequestInitWithRetry = {}): Promise<T> {\r\n    const { body, ...customConfig } = requestOptions\r\n    const headers = { 'Content-Type': 'application/json' }\r\n\r\n    const config: IRequestInitWithRetry = {\r\n      method: body ? 'POST' : 'GET',\r\n      ...customConfig,\r\n      headers: {\r\n        ...headers,\r\n        ...customConfig.headers,\r\n      },\r\n      signal: this.controller.signal,\r\n      retryOn: [503]\r\n    }\r\n\r\n    if (body) {\r\n      config.body = JSON.stringify(body)\r\n    }\r\n\r\n    let data\r\n    try {\r\n      const response = await wrappedFetch(endpoint, config)\r\n      console.log('api response: ', response)\r\n\r\n      if (response.ok) {\r\n        data = await response.json() as T\r\n        console.log('data', data)\r\n\r\n        return data\r\n      }\r\n\r\n      throw new Error(response.statusText)\r\n    } catch (err) {\r\n      return Promise.reject(err.message ? err.message : data)\r\n    }\r\n  }\r\n}","export function shuffle<T>(items: T[]) {\r\n  for (let i = items.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    const temp = items[i]\r\n    items[i] = items[j]\r\n    items[j] = temp\r\n  }\r\n\r\n  return items\r\n}","import { all, call, cancelled, put, takeLatest } from 'redux-saga/effects'\r\nimport { ApiClient } from '../api/client'\r\nimport { colorsReceived, colorsRequested, colorsRequestFailed } from '../commons/actions'\r\nimport { shuffle } from '../commons/shuffle'\r\nimport { Color } from '../features/colors/colorsReducer'\r\nimport { CallReturnType } from './sagaTypes'\r\n\r\n/**\r\n * Call mock fetch colors API\r\n */\r\n\r\n// FIXME: Need proper Typescript assessment/application\r\nfunction* fetchColors(action: CallReturnType<typeof colorsRequested>) {\r\n  const client = new ApiClient()\r\n  try {\r\n    const response: {colors: Color[]} = yield client.execute<{colors: Color[]}>(`http://localhost:4000/colors`)\r\n    const { colors } = response\r\n    const shuffled = shuffle<Color>(colors)\r\n    console.log(shuffled)\r\n    yield put(colorsReceived(shuffled.slice(0, action.payload.length)))\r\n  }\r\n  catch(error) {\r\n    yield put(colorsRequestFailed(error))\r\n  }\r\n  finally {\r\n    if (cancelled()) {\r\n      client.abort()\r\n    }\r\n  }\r\n}\r\n\r\nfunction* watchFetchColors() {\r\n  yield takeLatest(colorsRequested, fetchColors)\r\n}\r\n\r\n// single entry point to start all Sagas at once\r\nexport default function* rootSaga() {\r\n  yield all([\r\n    call(watchFetchColors)\r\n  ])\r\n}\r\n","import { configureStore, ThunkAction, Action, getDefaultMiddleware } from '@reduxjs/toolkit'\r\nimport { TypedUseSelectorHook, useSelector } from 'react-redux'\r\nimport createSagaMiddleware from 'redux-saga'\r\nimport { createInjectorsEnhancer } from 'redux-injectors'\r\n\r\nimport createReducer, { RootState } from './rootReducer'\r\nimport rootSaga from './sagas'\r\n\r\n// export const store = configureStore({\r\n//   reducer: {\r\n//     colors: colorsReducer\r\n//   },\r\n// })\r\n\r\nexport default function configureAppStore(initialState = {}) {\r\n  const reduxSagaMonitorOptions = {};\r\n  const sagaMiddleware = createSagaMiddleware(reduxSagaMonitorOptions);\r\n\r\n  const { run: runSaga } = sagaMiddleware;\r\n\r\n  // sagaMiddleware: Makes redux-sagas work\r\n  const middlewares = [sagaMiddleware];\r\n\r\n  const enhancers = [\r\n    createInjectorsEnhancer({\r\n      createReducer,\r\n      runSaga,\r\n    }),\r\n  ];\r\n\r\n  const store = configureStore({\r\n    reducer: createReducer(),\r\n    middleware: [...getDefaultMiddleware(), ...middlewares],\r\n    preloadedState: initialState,\r\n    devTools: process.env.NODE_ENV !== 'production',\r\n    enhancers,\r\n  });\r\n\r\n  sagaMiddleware.run(rootSaga);\r\n  return store;\r\n}\r\n\r\nexport const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>\r\n","import React, { useEffect } from 'react'\r\nimport { useDispatch } from 'react-redux'\r\nimport { useTypedSelector } from '../../app/store'\r\nimport { colorsRequested, colorToggled } from '../../commons/actions'\r\n\r\nexport const ColorsList = () => {\r\n  const colors = useTypedSelector(state => state.colors)\r\n  const colorsStatus = useTypedSelector(state => state.colors.status)\r\n\r\n  const dispatch = useDispatch()\r\n\r\n  useEffect(() => {\r\n    if (colorsStatus === 'idle') {\r\n      dispatch(colorsRequested('default'))\r\n    }\r\n  }, [colorsStatus, dispatch])\r\n\r\n  const renderedColors = colors.colors.map(color => (\r\n    <div\r\n      key={color.id}\r\n      className=\"color-wrapper\"\r\n      style={{\r\n        width: '100px',\r\n        height: '100px',\r\n        userSelect: 'none'\r\n      }}\r\n    >\r\n      <div\r\n        className=\"color\"\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          backgroundColor: color.hex,\r\n          cursor: 'pointer',\r\n          outline: color.selected ? `5px green solid` : 'none'\r\n        }}\r\n        onClick={() => dispatch(colorToggled(color))}\r\n      >\r\n        {color.name}\r\n      </div>\r\n    </div>\r\n  ))\r\n\r\n  return (\r\n    <section className=\"colors-list\">\r\n      <h2>Colors!</h2>\r\n      <p>status of asyncFetchColors: {colorsStatus}</p>\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          flexWrap: 'wrap',\r\n        }}\r\n      >\r\n        {renderedColors}\r\n      </div>\r\n    </section>\r\n  )\r\n}","import React from 'react'\r\nimport {\r\n  BrowserRouter as Router,\r\n  Switch,\r\n  Route,\r\n  Redirect,\r\n} from 'react-router-dom'\r\n\r\nimport { SearchForm } from './features/colors/SearchForm'\r\nimport { ColorsList } from './features/colors/ColorsList'\r\n\r\nimport './App.css'\r\n\r\nfunction App() {\r\n  return (\r\n    <Router>\r\n      <div className=\"App\">\r\n        <Switch>\r\n          <Route\r\n            exact\r\n            path=\"/\"\r\n            render={() => (\r\n              <>\r\n                <SearchForm />\r\n                <ColorsList />\r\n              </>\r\n            )}\r\n          />\r\n          <Redirect to=\"/\" />\r\n        </Switch>\r\n      </div>\r\n    </Router>\r\n  )\r\n}\r\n\r\nexport default App\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n)\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\r\n}\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets see https://github.com/facebook/create-react-app/issues/2374\r\n      return\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config)\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          )\r\n        })\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing\r\n        if (installingWorker == null) {\r\n          return\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              )\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration)\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.')\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error)\r\n    })\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type')\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload()\r\n          })\r\n        })\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config)\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      )\r\n    })\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister()\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message)\r\n      })\r\n  }\r\n}\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport './index.css'\r\nimport App from './App'\r\nimport configureStore from './app/store'\r\nimport { Provider } from 'react-redux'\r\nimport * as serviceWorker from './serviceWorker'\r\n\r\nconst initialState = {}\r\nconst store = configureStore(initialState)\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n)\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister()\r\n"],"sourceRoot":""}