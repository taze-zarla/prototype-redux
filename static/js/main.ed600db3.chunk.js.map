{"version":3,"sources":["api/client.ts","commons/randomHexColor.ts","features/colors/colorsSlice.ts","app/store.ts","features/colors/SearchForm.tsx","features/colors/ColorsList.tsx","App.tsx","serviceWorker.ts","api/server.ts","index.tsx"],"names":["client","endpoint","a","requestOptions","body","customConfig","headers","config","method","JSON","stringify","window","fetch","response","json","data","ok","Error","statusText","Promise","reject","message","randomHexColor","Math","floor","random","toString","get","post","fetchColors","createAsyncThunk","keywords","colors","condition","arg","api","getState","status","colorsSlice","createSlice","name","initialState","error","reducers","toggleColorSelected","state","action","color","find","id","payload","selected","colorAdded","push","extraReducers","pending","type","fulfilled","rejected","actions","store","configureStore","reducer","colorsReducer","useAppDispatch","useDispatch","useTypedSelector","useSelector","SearchForm","colorsStatus","useState","setKeywords","dirty","setDirty","dispatch","debouncedDispatch","useDebouncedCallback","useEffect","aria-label","value","onChange","e","term","currentTarget","callback","ColorsList","renderedColors","map","className","style","width","height","userSelect","backgroundColor","hex","cursor","outline","onClick","display","flexWrap","App","exact","path","render","to","Boolean","location","hostname","match","defaultColorsArr","environment","createServer","routes","this","namespace","timing","schema","req","params","console","log","length","randomColors","i","randomHex","makeServer","process","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.ed600db3.chunk.js","sourcesContent":["// A tiny wrapper around fetch(), borrowed from\r\n// https://kentcdodds.com/blog/replace-axios-with-a-simple-custom-fetch-wrapper\r\n\r\nexport async function client<T>(endpoint: string, requestOptions: RequestInit = {}): Promise<T> {\r\n  const { body, ...customConfig } = requestOptions\r\n  const headers = { 'Content-Type': 'application/json' }\r\n\r\n  const config: RequestInit = {\r\n    method: body ? 'POST' : 'GET',\r\n    ...customConfig,\r\n    headers: {\r\n      ...headers,\r\n      ...customConfig.headers,\r\n    },\r\n  }\r\n\r\n  if (body) {\r\n    config.body = JSON.stringify(body)\r\n  }\r\n\r\n  let data\r\n  try {\r\n    const response = await window.fetch(endpoint, config)\r\n    data = await response.json() as T\r\n    if (response.ok) {\r\n      return data\r\n    }\r\n    throw new Error(response.statusText)\r\n  } catch (err) {\r\n    return Promise.reject(err.message ? err.message : data)\r\n  }\r\n}\r\n\r\nclient.get = function<T>(endpoint: string, requestOptions: RequestInit = {}): Promise<T> {\r\n  return client<T>(endpoint, { ...requestOptions, method: 'GET' })\r\n}\r\n\r\nclient.post = function<T>(endpoint: string, requestOptions: RequestInit = {}): Promise<T> {\r\n  const { body, ...customConfig } = requestOptions\r\n\r\n  return client<T>(endpoint, { ...customConfig, body })\r\n}\r\n","export function randomHexColor(): string {\r\n  return `#${Math.floor(Math.random()*16777215).toString(16)}`\r\n}","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\r\nimport { client } from '../../api/client'\r\nimport { AppThunk } from '../../app/store'\r\nimport { randomHexColor } from '../../commons/randomHexColor'\r\nimport { sleep } from '../../commons/sleep'\r\nexport interface Color {\r\n  id: string,\r\n  hex: string,\r\n  name: string,\r\n  selected: boolean,\r\n}\r\n\r\ninterface ColorsState {\r\n  colors: Color[]\r\n  status: 'idle' | 'fetching' | 'succeeded' | 'failed'\r\n  error: string | null\r\n}\r\n\r\nconst initialState: ColorsState = {\r\n  colors: [],\r\n  status: 'idle',\r\n  error: null\r\n}\r\n\r\nexport const fetchColors = createAsyncThunk(\r\n  'colors/fetchColors',\r\n  async (keywords: string) => {\r\n    const response = await client.get<{colors: Color[]}>(`/fakeApi/colors/${keywords}`)\r\n    return response.colors\r\n  },\r\n  {\r\n    condition: (arg, api) => {\r\n      const { colors } = api.getState() as { colors: ColorsState } //FIXME: proper typing via createAsyncThunk<Return, void, {state: RootState}>?\r\n      return colors.status !== 'fetching'\r\n    }\r\n  }\r\n)\r\n\r\nexport const colorsSlice = createSlice({\r\n  name: 'colors',\r\n  initialState,\r\n  reducers: {\r\n    toggleColorSelected(state, action: PayloadAction<Color>) {\r\n      const color = state.colors.find(color => color.id === action.payload.id)\r\n\r\n      if (color) {\r\n        color.selected = !color.selected\r\n      }\r\n    },\r\n    colorAdded(state, action: PayloadAction<Color>) {\r\n      state.colors.push(action.payload)\r\n    }\r\n  },\r\n  extraReducers: {\r\n    [fetchColors.pending.type]: (state, action) => {\r\n      state.status = 'fetching'\r\n    },\r\n    [fetchColors.fulfilled.type]: (state, action: PayloadAction<Color[]>) => {\r\n      state.status = 'succeeded'\r\n      state.colors = action.payload\r\n    },\r\n    [fetchColors.rejected.type]: (state, action) => { //FIXME: proper typing for action.error.message?\r\n      state.status = 'failed'\r\n      state.colors = action.error.message\r\n    },\r\n  }\r\n})\r\n\r\nexport const { toggleColorSelected, colorAdded } = colorsSlice.actions\r\n\r\nexport const addRandomColor = (): AppThunk => async (dispatch) => {\r\n  await sleep(5000)\r\n\r\n  const randomColor = randomHexColor()\r\n\r\n  dispatch(colorAdded({\r\n    id: randomColor,\r\n    hex: randomColor,\r\n    name: randomColor,\r\n    selected: false\r\n  }))\r\n}\r\n\r\nexport default colorsSlice.reducer","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit'\r\nimport colorsReducer from '../features/colors/colorsSlice'\r\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    colors: colorsReducer\r\n  },\r\n})\r\n\r\nexport type RootState = ReturnType<typeof store.getState>\r\nexport type AppDispatch = typeof store.dispatch\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\r\nexport const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>\r\n","import React, { useEffect, useState } from 'react'\r\nimport { useAppDispatch, useTypedSelector } from '../../app/store'\r\nimport { useDebouncedCallback } from 'use-debounce/lib'\r\nimport { fetchColors } from './colorsSlice'\r\n// import { addRandomColor } from './colorsSlice'\r\n\r\nexport const SearchForm = () => {\r\n  const colorsStatus = useTypedSelector(state => state.colors.status)\r\n\r\n  const [keywords, setKeywords] = useState<string>('')\r\n  const [dirty, setDirty] = useState<boolean>(false)\r\n\r\n  const dispatch = useAppDispatch()\r\n\r\n  const debouncedDispatch = useDebouncedCallback(dispatch, 500)\r\n\r\n  const onKeywordsChanged = (e: React.FormEvent<HTMLInputElement>) => {\r\n    const term = e.currentTarget.value\r\n    setKeywords(term)\r\n    setDirty(true)\r\n    // debouncedDispatch.callback(addRandomColor())\r\n    if (term) {\r\n      debouncedDispatch.callback(fetchColors(term))\r\n    }\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (dirty && colorsStatus !== 'fetching' && keywords) {\r\n      dispatch(fetchColors(keywords))\r\n    }\r\n\r\n    if (colorsStatus === 'succeeded' || colorsStatus === 'failed') {\r\n      setDirty(false)\r\n    }\r\n  }, [dirty, colorsStatus, keywords, dispatch])\r\n\r\n  return <div>\r\n    <div>============</div>\r\n    <div>Search Colors</div>\r\n    <input\r\n      aria-label=\"Enter search keywords\"\r\n      value={keywords}\r\n      onChange={onKeywordsChanged}\r\n    />\r\n  </div>\r\n}","import React, { useEffect } from 'react'\r\nimport { useAppDispatch, useTypedSelector } from '../../app/store'\r\n\r\nimport { fetchColors, toggleColorSelected } from './colorsSlice'\r\n\r\nexport const ColorsList = () => {\r\n  const colors = useTypedSelector(state => state.colors)\r\n  const colorsStatus = useTypedSelector(state => state.colors.status)\r\n\r\n  const dispatch = useAppDispatch()\r\n\r\n  useEffect(() => {\r\n    if (colorsStatus === 'idle') {\r\n      dispatch(fetchColors('default'))\r\n    }\r\n  }, [colorsStatus, dispatch])\r\n\r\n  const renderedColors = colors.colors.map(color => (\r\n    <div\r\n      className=\"color-wrapper\"\r\n      key={color.id}\r\n      style={{\r\n        width: '100px',\r\n        height: '100px',\r\n        userSelect: 'none'\r\n      }}\r\n    >\r\n      <div\r\n        className=\"color\"\r\n        style={{\r\n          width: '100%',\r\n          height: '100%',\r\n          backgroundColor: color.hex,\r\n          cursor: 'pointer',\r\n          outline: color.selected ? `5px green solid` : 'none'\r\n        }}\r\n        onClick={() => dispatch(toggleColorSelected(color))}\r\n      >\r\n        {color.name}\r\n      </div>\r\n    </div>\r\n  ))\r\n\r\n  return (\r\n    <section className=\"colors-list\">\r\n      <h2>Colors!</h2>\r\n      <p>status of fetchColors: {colorsStatus}</p>\r\n      <div\r\n        style={{\r\n          display: 'flex',\r\n          flexWrap: 'wrap',\r\n        }}\r\n      >\r\n        {renderedColors}\r\n      </div>\r\n    </section>\r\n  )\r\n}","import React from 'react'\r\nimport {\r\n  BrowserRouter as Router,\r\n  Switch,\r\n  Route,\r\n  Redirect,\r\n} from 'react-router-dom'\r\n\r\nimport { SearchForm } from './features/colors/SearchForm'\r\nimport { ColorsList } from './features/colors/ColorsList'\r\n\r\nimport './App.css'\r\n\r\nfunction App() {\r\n  return (\r\n    <Router>\r\n      <div className=\"App\">\r\n        <Switch>\r\n          <Route\r\n            exact\r\n            path=\"/\"\r\n            render={() => (\r\n              <>\r\n                <SearchForm />\r\n                <ColorsList />\r\n              </>\r\n            )}\r\n          />\r\n          <Redirect to=\"/\" />\r\n        </Switch>\r\n      </div>\r\n    </Router>\r\n  )\r\n}\r\n\r\nexport default App\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n)\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\r\n}\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets see https://github.com/facebook/create-react-app/issues/2374\r\n      return\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config)\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          )\r\n        })\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing\r\n        if (installingWorker == null) {\r\n          return\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              )\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration)\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.')\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error)\r\n    })\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type')\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload()\r\n          })\r\n        })\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config)\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      )\r\n    })\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister()\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message)\r\n      })\r\n  }\r\n}\r\n","import { createServer } from 'miragejs'\r\nimport { randomHexColor } from '../commons/randomHexColor'\r\n\r\nimport { Color } from '../features/colors/colorsSlice'\r\n\r\nconst defaultColorsArr: Color[] = [\r\n  {\r\n    id: '#ff0000',\r\n    hex: '#ff0000',\r\n    name: 'red',\r\n    selected: false\r\n  },\r\n  {\r\n    id: '#00ff00',\r\n    hex: '#00ff00',\r\n    name: 'green',\r\n    selected: false\r\n  },\r\n  {\r\n    id: '#0000ff',\r\n    hex: '#0000ff',\r\n    name: 'blue',\r\n    selected: false\r\n  },\r\n]\r\n\r\nexport function makeServer({ environment = \"test\" }) {\r\n  return createServer({\r\n    environment,\r\n    routes() {\r\n      this.namespace = 'fakeApi'\r\n      this.timing = 5000\r\n\r\n      this.get('/colors/:keywords', (schema, req) => {\r\n        const keywords = req.params.keywords\r\n        console.log('keywords: ', keywords)\r\n\r\n        if (!keywords || keywords === 'default') {\r\n          return {\r\n            colors: defaultColorsArr\r\n          }\r\n        }\r\n\r\n        const length = keywords.length\r\n        let randomColors: Color[] = []\r\n\r\n        for (let i = 0; i < length; i++) {\r\n          const randomHex = randomHexColor()\r\n          randomColors.push({\r\n            id: randomHex,\r\n            hex: randomHex,\r\n            name: randomHex,\r\n            selected: false\r\n          })\r\n        }\r\n\r\n        return {\r\n          colors: randomColors\r\n        }\r\n      })\r\n    }\r\n  })\r\n}","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport './index.css'\r\nimport App from './App'\r\nimport { store } from './app/store'\r\nimport { Provider } from 'react-redux'\r\nimport * as serviceWorker from './serviceWorker'\r\nimport { makeServer } from './api/server'\r\n\r\nconst environment = process.env.NODE_ENV\r\n\r\n// if (environment !== 'production') {\r\n  makeServer({ environment })\r\n// }\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n)\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister()\r\n"],"sourceRoot":""}